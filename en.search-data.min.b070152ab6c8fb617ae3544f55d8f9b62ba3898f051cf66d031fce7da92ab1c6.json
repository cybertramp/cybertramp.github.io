[{"id":0,"href":"/posts/20210822_003/","title":"Build - nvme-cli","section":"/var/posts","content":"Build - nvme-cli #  1. 클론/컴파일/설치 #  git clone https://github.com/linux-nvme/nvme-cli.git cd nvme-cli make make install # RUN nvme --version 2. 커스텀 플러그인 추가 #  플러그인은 todd라는 명으로 추가한다.\nmkdir -p plugins/todd   plugins/todd/todd-nvme.h\n#undef CMD_INC_FILE #define CMD_INC_FILE plugins/todd/todd-nvme  #if !defined(TODD_NVME) || defined(CMD_HEADER_MULTI_READ) #define TODD_NVME  #include \u0026#34;cmd.h\u0026#34;#include \u0026lt;stdio.h\u0026gt; PLUGIN(NAME(\u0026#34;todd\u0026#34;, \u0026#34;Todd plugin\u0026#34;), COMMAND_LIST( ENTRY(\u0026#34;list\u0026#34;,\u0026#34;List available FADU devices\u0026#34;,todd_list) ) ); #endif  #include \u0026#34;define_cmd.h\u0026#34;  plugins/todd/todd-nvme.c\n#include \u0026#34;nvme.h\u0026#34; #define CREATE_CMD #include \u0026#34;todd-nvme.h\u0026#34; static int todd_list(int argc, char **argv, struct command *cmd, struct plugin *plugin){ printf(\u0026#34;Hello world!\u0026#34;); return 0; }   Makefile\n# 변경전 PLUGIN_OBJS := \\  plugins/intel/intel-nvme.o \\  plugins/lnvm/lnvm-nvme.o \\  plugins/memblaze/memblaze-nvme.o \\  plugins/wdc/wdc-nvme.o \\  plugins/wdc/wdc-utils.o \\  plugins/huawei/huawei-nvme.o \\  plugins/netapp/netapp-nvme.o \\  plugins/toshiba/toshiba-nvme.o \\  plugins/micron/micron-nvme.o \\  plugins/seagate/seagate-nvme.o \\  plugins/virtium/virtium-nvme.o \\  plugins/shannon/shannon-nvme.o \\  plugins/dera/dera-nvme.o # 변경후 PLUGIN_OBJS := \\  plugins/intel/intel-nvme.o \\  plugins/lnvm/lnvm-nvme.o \\  plugins/memblaze/memblaze-nvme.o \\  plugins/wdc/wdc-nvme.o \\  plugins/wdc/wdc-utils.o \\  plugins/huawei/huawei-nvme.o \\  plugins/netapp/netapp-nvme.o \\  plugins/toshiba/toshiba-nvme.o \\  plugins/micron/micron-nvme.o \\  plugins/seagate/seagate-nvme.o \\  plugins/virtium/virtium-nvme.o \\  plugins/shannon/shannon-nvme.o \\  plugins/dera/dera-nvme.o \\  plugins/todd/todd-nvme.o   컴파일/설치/실행\npwd /root/nvme-cli # run on root permission state! make clean make make install # run  /usr/sbin/nvme nvme todd list   "},{"id":1,"href":"/posts/20210822_002/","title":"Installation - Django","section":"/var/posts","content":"Installation - Django #  1. Installation #  (1) venv 설치 #  개발 환경을 깔끔하게 관리하기 위한 도구\nmkdir v1 cd v1 sudo apt install python3-venv -y python3 -m venv v1 # 개발환경 적용 source v1/bin/activate (2) Django 설치 #  python3 -m pip install --upgrade pip pip install django~=2.0.0 mkdir project1 django-admin startproject mysite . 다음과 같은 구조로 파일이 생성됨\n  생성된 구조\n. ├── manage.py └── mysite ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ └── settings.cpython-36.pyc ├── settings.py ├── urls.py └── wsgi.py 2 directories, 7 files   (3) 설정 변경 #    타임존/정적파일 위치 변경\n기존 것을 변경하되 없으면 추가\nmysite/settings.py\nTIME_ZONE = \u0026#39;Asia/Seoul\u0026#39; STATIC_URL = \u0026#39;/static/\u0026#39; STATIC_ROOT = os.path.join(BASE_DIR, \u0026#39;static\u0026#39;)   (4) DB 설정 #  Django는 기본적으로 sqlite3가 적용되어 있음\nmysite/settings.py\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: os.path.join(BASE_DIR, \u0026#39;db.sqlite3\u0026#39;), } } SITE에 DB를 생성하기 위해서는 커맨드를 실행해야함\n./manage.py migrate (5) 서버 실행 #  ./manage.py runserver 2. App 만들기 #  (1) 생성 #  ./manage.py startapp blog "},{"id":2,"href":"/posts/20210822_005/","title":"Installation - ElasticSearch","section":"/var/posts","content":"install Elasticsearch #   주의   service로 동작하므로 wsl에서 테스트 불가\n  참고   https://www.digitalocean.com/community/tutorials/how-to-install-elasticsearch-logstash-and-kibana-elastic-stack-on-ubuntu-20-04    $ curl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - $ echo \u0026#34;deb https://artifacts.elastic.co/packages/7.x/apt stable main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list $ sudo apt update $ sudo apt install elasticsearch $ sudo vi /etc/elasticsearch/elasticsearch.yml /etc/elasticsearch/elasticsearch.yml\n# ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: localhost $ sudo systemctl start elasticsearch $ sudo systemctl enable elasticsearch   Request Test\n$ curl -X GET \u0026#34;localhost:9200\u0026#34;  ![[Pasted image 20210527112333.png]]   Install Kibana  $ sudo apt install nginx $ sudo apt install kibana $ sudo systemctl enable kibana $ sudo systemctl start kibana $ echo \u0026#34;kibanaadmin:`openssl passwd -apr1`\u0026#34; | sudo tee -a /etc/nginx/htpasswd.users $ sudo vi /etc/nginx/sites-available/{SERVER_NAME}   localhost 이외에서 접근 허용\n/etc/kibana/kibana.yml\nserver.host: \u0026#34;0.0.0.0\u0026#34; elasticsearch.hosts: \\[\u0026#34;http://localhost:9200\u0026#34;\\]    /etc/nginx/sites-available/{SERVER_NAME}\nserver { listen 5601; server_name your_domain; auth_basic \u0026#34;Restricted Access\u0026#34;; auth_basic_user_file /etc/nginx/htpasswd.users; location / { proxy_pass http://localhost:5601; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#39;upgrade\u0026#39;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } $ sudo ln -s /etc/nginx/sites-available/{SERVER_NAME} /etc/nginx/sites-enabled/{SERVER_NAME} $ sudo nginx -t $ sudo systemctl start nginx $ sudo systemctl enable nginx $ sudo systemctl reload nginx Install Logstash  $ sudo apt install logstash $ sudo vi /etc/logstash/conf.d/logstash.conf /etc/logstash/conf.d/logstash.conf\ninput { file { path =\u0026gt; [ \u0026#34;/FADU-FTP/TESTLOGS/*.*\u0026#34; ] start_position =\u0026gt; \u0026#34;beginning\u0026#34; sincedb_path =\u0026gt; \u0026#34;/dev/null\u0026#34; } } filter { grok { match =\u0026gt; {\u0026#34;path\u0026#34; =\u0026gt; \u0026#34;%{GREEDYDATA:lotid}_ST470_%{GREEDYDATA:tester}-%{GREEDYDATA:dut}_%{GREEDYDATA:testtime}.txt\u0026#34;} } } output { elasticsearch { hosts =\u0026gt; [\u0026#34;localhost:9200\u0026#34;] } } # configure test $ sudo -u logstash /usr/share/logstash/bin/logstash --path.settings /etc/logstash -t "},{"id":3,"href":"/posts/20210822_004/","title":"Installation - gitea(docker)","section":"/var/posts","content":"Installation - getea #  참고\n  https://docs.docker.com/compose/install/  https://docs.gitea.io/en-us/install-with-docker/  apt install docker docker.io -y sudo curl -L \u0026#34;[https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)](https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname%20-s)-$(uname%20-m))\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose mkdir dockers cd dockers vi docker-compose.yml docker-compose.yml\nversion: \u0026#34;2\u0026#34; networks: gitea: external: false services: server: image: gitea/gitea:latest environment: - USER\\_UID=1000 - USER\\_GID=1000 restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - \u0026#34;3000:3000\u0026#34; - \u0026#34;2222:22\u0026#34; docker-compose up docker-compose start "},{"id":4,"href":"/posts/20210822_001/","title":"Installation - Mongo DB","section":"/var/posts","content":"Mongo DB Installation #   참고\n1. 키 추가 #  wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add - 2. 레포지토리 추가 #  echo \u0026#34;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse\u0026#34; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list 3. 패키지 최신화 및 설치 #  sudo apt update sudo apt-get install -y mongodb-org 4. 서비스 시작 #  service mongod start service mongod enable service mongod status 5. 관리자 계정 생성 #  MongoDB CLI를 통해 인증을 위한 관리자 계정을 생성한다.\nmongo\nuse admin db.createUser( { user: \u0026#34;원하는 계정 이름\u0026#34;, pwd: \u0026#34;패스워드\u0026#34;, roles: [\u0026#39;root\u0026#39;] } ) 6. MongoDB 바인딩 설정 및 관리자 계정 설정 #  기본적으로 처음에 127.0.0.1로 바인딩 되게 설정되어 있으므로 수정해주어야 외부에서 접근이 가능하다. 또한 MongoDB는 기존 Mysql or MariaDB와 달리 설치시 계정을 설정하지 않는다. 따라서 보안을 위해 따로 설정을 해주어야한다.\n/etc/mongod.conf\n# network interfaces net: port: 27017 bindIp: 0.0.0.0 # Authentication security: authorization: enabled 7. 접속 확인 #  세가지 방법이 가능하다. 커맨드를 통해 or 쉘에 들어가있는 상태 or ORM을 통한 접속 확인\n  커맨드\nmongo -u \u0026#34;admin\u0026#34; -p --authenticationDatabase \u0026#34;admin\u0026#34;   쉘\nuse admin db.auth(\u0026#34;계정\u0026#34;, \u0026#34;암호\u0026#34; )   Mongoose\nmongoose.connect(\u0026#39;mongodb://계정:암호@호스트:포트/admin\u0026#39;, { dbName: \u0026#39;사용할 데이터베이스\u0026#39; });    몽고 DB는 실제로도 DB에 계정을 설정안해 암호화 당하고 비트코인 요구를 당한 적이 있으니 필이 계정을 설정하여 접근하는 것이좋다.\n "},{"id":5,"href":"/posts/20210805_001/","title":"Re-Start first post","section":"/var/posts","content":"새로운 시작 😲\n블로그를 안했더니\u0026hellip; 마음에 드는 테마가 두둥등장 했었다.\n"},{"id":6,"href":"/profile/","title":"/etc/info","section":"Introduction","content":"/etc/info/profile #  I\u0026rsquo;m Cybertramp working as Test/SW Engineer in FADU.\nI just like computers. There is no reason.\nI interested in Linux, C ,Python, Vue, node, Docker. I am not good enough, but I am trying to work hard.\n /etc/info/info-cybertramp #  🌱 Status: I\u0026rsquo;m ready, any work!\n📫 Email: paran_son(at)outlook.com\n🎫 github: github.com/cybertramp\n⚡ Fun fact: I Love League of Legends :), My favorite Vel\u0026rsquo;Koz\n  /etc/info/stacks #  I Can 🦾 #  Language #     Linux experience #   DBs #   Tools #   studying ⛷ #   "}]